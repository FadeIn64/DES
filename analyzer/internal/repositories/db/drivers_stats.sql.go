// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: drivers_stats.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDriverByPosition = `-- name: GetDriverByPosition :one
select position, meeting_key, session_key, driver_number, completed_sectors, date_start, lap_duration, lap_number, sector_duration, date_end, info_time, is_pit_out_lap, updated_at from drivers_stats_with_positions
where meeting_key = $1 and session_key = $2 and position = $3
`

type GetDriverByPositionParams struct {
	MeetingKey int32
	SessionKey int32
	Position   int64
}

func (q *Queries) GetDriverByPosition(ctx context.Context, arg GetDriverByPositionParams) (DriversStatsWithPosition, error) {
	row := q.db.QueryRow(ctx, getDriverByPosition, arg.MeetingKey, arg.SessionKey, arg.Position)
	var i DriversStatsWithPosition
	err := row.Scan(
		&i.Position,
		&i.MeetingKey,
		&i.SessionKey,
		&i.DriverNumber,
		&i.CompletedSectors,
		&i.DateStart,
		&i.LapDuration,
		&i.LapNumber,
		&i.SectorDuration,
		&i.DateEnd,
		&i.InfoTime,
		&i.IsPitOutLap,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverStats = `-- name: GetDriverStats :one
select position, meeting_key, session_key, driver_number, completed_sectors, date_start, lap_duration, lap_number, sector_duration, date_end, info_time, is_pit_out_lap, updated_at from drivers_stats_with_positions
where meeting_key = $1 and session_key = $2 and driver_number = $3
`

type GetDriverStatsParams struct {
	MeetingKey   int32
	SessionKey   int32
	DriverNumber int32
}

func (q *Queries) GetDriverStats(ctx context.Context, arg GetDriverStatsParams) (DriversStatsWithPosition, error) {
	row := q.db.QueryRow(ctx, getDriverStats, arg.MeetingKey, arg.SessionKey, arg.DriverNumber)
	var i DriversStatsWithPosition
	err := row.Scan(
		&i.Position,
		&i.MeetingKey,
		&i.SessionKey,
		&i.DriverNumber,
		&i.CompletedSectors,
		&i.DateStart,
		&i.LapDuration,
		&i.LapNumber,
		&i.SectorDuration,
		&i.DateEnd,
		&i.InfoTime,
		&i.IsPitOutLap,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriversRaceDataByDriver = `-- name: GetDriversRaceDataByDriver :many
select position, meeting_key, session_key, driver_number, lap_number, interval, prediction_laps_to_overtake, last_lap_duration, pitsops, last_pit_lap, full_name, abbreviation, name, color from full_driver_data
    where driver_number = $1
`

func (q *Queries) GetDriversRaceDataByDriver(ctx context.Context, driverNumber int32) ([]FullDriverDatum, error) {
	rows, err := q.db.Query(ctx, getDriversRaceDataByDriver, driverNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDriverDatum
	for rows.Next() {
		var i FullDriverDatum
		if err := rows.Scan(
			&i.Position,
			&i.MeetingKey,
			&i.SessionKey,
			&i.DriverNumber,
			&i.LapNumber,
			&i.Interval,
			&i.PredictionLapsToOvertake,
			&i.LastLapDuration,
			&i.Pitsops,
			&i.LastPitLap,
			&i.FullName,
			&i.Abbreviation,
			&i.Name,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriversRaceDataByMeeting = `-- name: GetDriversRaceDataByMeeting :many
select position, meeting_key, session_key, driver_number, lap_number, interval, prediction_laps_to_overtake, last_lap_duration, pitsops, last_pit_lap, full_name, abbreviation, name, color from full_driver_data
    where meeting_key = $1
`

func (q *Queries) GetDriversRaceDataByMeeting(ctx context.Context, meetingKey int32) ([]FullDriverDatum, error) {
	rows, err := q.db.Query(ctx, getDriversRaceDataByMeeting, meetingKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDriverDatum
	for rows.Next() {
		var i FullDriverDatum
		if err := rows.Scan(
			&i.Position,
			&i.MeetingKey,
			&i.SessionKey,
			&i.DriverNumber,
			&i.LapNumber,
			&i.Interval,
			&i.PredictionLapsToOvertake,
			&i.LastLapDuration,
			&i.Pitsops,
			&i.LastPitLap,
			&i.FullName,
			&i.Abbreviation,
			&i.Name,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriversStats = `-- name: GetDriversStats :many
select position, meeting_key, session_key, driver_number, completed_sectors, date_start, lap_duration, lap_number, sector_duration, date_end, info_time, is_pit_out_lap, updated_at from drivers_stats_with_positions
where meeting_key = $1 and session_key = $2
order by position
`

type GetDriversStatsParams struct {
	MeetingKey int32
	SessionKey int32
}

func (q *Queries) GetDriversStats(ctx context.Context, arg GetDriversStatsParams) ([]DriversStatsWithPosition, error) {
	rows, err := q.db.Query(ctx, getDriversStats, arg.MeetingKey, arg.SessionKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DriversStatsWithPosition
	for rows.Next() {
		var i DriversStatsWithPosition
		if err := rows.Scan(
			&i.Position,
			&i.MeetingKey,
			&i.SessionKey,
			&i.DriverNumber,
			&i.CompletedSectors,
			&i.DateStart,
			&i.LapDuration,
			&i.LapNumber,
			&i.SectorDuration,
			&i.DateEnd,
			&i.InfoTime,
			&i.IsPitOutLap,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDriversInterval = `-- name: UpsertDriversInterval :exec
insert into drivers_intervals (meeting_key, session_key, driver_number, interval, prediction_laps_to_overtake)
values ($1, $2, $3, $4, $5)
on conflict (meeting_key, session_key, driver_number) do update
set
    interval = excluded.interval,
    prediction_laps_to_overtake = excluded.prediction_laps_to_overtake
`

type UpsertDriversIntervalParams struct {
	MeetingKey               int32
	SessionKey               int32
	DriverNumber             int32
	Interval                 float64
	PredictionLapsToOvertake pgtype.Int4
}

func (q *Queries) UpsertDriversInterval(ctx context.Context, arg UpsertDriversIntervalParams) error {
	_, err := q.db.Exec(ctx, upsertDriversInterval,
		arg.MeetingKey,
		arg.SessionKey,
		arg.DriverNumber,
		arg.Interval,
		arg.PredictionLapsToOvertake,
	)
	return err
}
